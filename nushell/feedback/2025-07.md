# Nushell Feedback (state: 2025-07)

Before i get started:
* I really like nu.
* It replaced most of my python and bash scripts.
* You guys are doing a great hobby (i guess job is the wrong word?)
* Just because I (1 person) thinks something is "bad" does not mean that it is objectively bad and has to be changed immediately.
  * Feel free to ignore this, discuss this, or whatever.

---

## Context: My usecase

1. Simplification of complex shell tasks (`ls | each`, etc)
1. Replace bash scripts (makefiles, program wrappers, etc)
1. Replace python scripts (web-scrapers, filesystem automation, html-file generation based on json, etc)
  * I use (my own) libraries a lot
1. (Sometimes) as primary shell

---

## `use` feels like a second class citizen

In my eyes `use` is way more "nu" than `source` (and since `source` used to be deprecated i think other people agree?).  
But in terms of bug-fix-speed, bug amount, usability, etc it feels like `source`, but worse.

2 examples:

### hooks

`$env.config.hooks` do not work with `use` due to a bug (`#8856`).

### `source-env`

`use` does not source `export-env` and there is no `use --env` flag or whatever.
Thus a import looks like this:

```nu
use foo.nu *

export-env {
  source-env foo.nu
}

export def my_function [] {
  source-env foo.nu  # load env in case the script importing this forgets to `source-env` this file (see std/log bug)

  # normal function code
}
```

instead of

```nu
use --env foo.nu *  # (my proposal)
# or
source foo.nu
```

and to be honest half the time (including while writing this) i accidentally use
`load-env` instead of `source-env` and then have to find the bug-cause later.

---

## plugins

Plugins are a nice addition and make some nice things possible.  
Good examples:
* [nu_plugin_http](https://github.com/cablehead/nu_plugin_http)
  * It is otherwise not possible to share 1 open port between multiple nu threads, which is needed if you want to reimplement a git server or similar.
* [nu_plugin_from_sse](https://github.com/cablehead/nu_plugin_from_sse)
  * Streaming + decoding is currently not really possible in vanilla nu
* etc

But i also see a few problems with it:

### It is not usable in scripts

A library written in nu can just be used in a script and for distribution ([fully automatic](https://github.com/Jan9103/merge_nu_scripts)) embedded.

Meanwhile plugins require:
* A workaround to load the plugin within the script (which probably does not work on windows thanks to it ignoring hashbangs, etc)
* A (potentially very long) explanation for the user on how to install the plugin
  * If i want to share a script with a non-nu buddy the barrier of entry rises exponentially
  * It takes forever to compile a rust plugin
  * Nu can often be installed via `nix`, `xbps`, `winget`, etc - but plugins require `git`, `rustup`, `cargo`, `$env.PATH`, `plugin add`, etc knowledge

A external binary like [htmlq](https://github.com/mgdm/htmlq), [fzf](https://github.com/junegunn/fzf), can easily be `def --wrapped` and usually installed via package-manager (it is at least not more complex to install than a plugin).

### Nu version compatibility

* Users have to wait with nu updates until every plugin has updated (which can take months in some cases (not naming names, but if you know you know..))
  * Maintaining a plugin is a lot of work and many get abandoned randomly
  * As end-user you cannot distinguish a half-year inactive plugin from a abandoned one
  * If you are already using one you have to either fork something written in a language you don't know (and then have the maintainer-problems) or find some other solution
* If nu is installed via a package-manager they have to halt all updates (potentially including firefox / kernel **security** fixes) until they can update nu again
* There is no notification when a plugin is finally update-ready (some plugins have github releases so you can "watch" it, but most do not)

### Rust plugins are to hard to create and maintain

Yes it could be worse, but many plugins are created by for example a non-developer who wants support for their [FASTA](https://en.wikipedia.org/wiki/FASTA_format) files.  
Rust is also already a lot of overhead for lets say java(-script) devs.

* Once again the version compatibility problem
* You need to learn a lot extra to write a nu plugin
* There is a lot of data-conversion and `call.head` boilerplate involved

### Non-Rust plugins are hard to create and maintain

There are currently AFAIK no well maintained libraries for any language except rust.

Thus:
* You have to write the plugin interface from scratch (including manually sending bytes to stdout)
* You have to either write a automatic data converter or end up with 80% of your code being data-type-wrapping boilerplate
* The nu protocol does sometimes change (without proper breaking-change announcements) causing such plugins to just break randomly
  * Noone seems to check if the official (python) example is still worked in latest
* not sure on this, but from what i heard you can't use script-language plugins on windows properly?

### Plugins are not powerful enough

Some things i could see a plugin being useful for:
* Changing directory (writing `$env`) (think `zoxide`, python venv, `nix shell`, etc)
* Enhancing reedline ("live" tab completion, kakoune edit mode, etc)
* Debugging utils (not possible since no access to engine state)
* Integrating with existing datatypes
  * `query db` exists, but it can only be used with the `in-memory-sqlite` type. How about a `pgsql`, `mysql`, `mongodb`, etc plugin?
* Serializing nu's state (variables, functions, etc) into a `source`-able script for later use (`scope` cant handle overlays, etc)
* Pre-compiling nu code (similar to `__pycache__`) and directly loading it
* Custom datatypes (`distance` (meter, feet, etc), temperature (`°F`, `°C`, `°K`, etc), etc)
* etc

### Plugins are overused

Yes i know this is not on nu, but it still bothers me since its specifically written for nu, but not usable in nu (scripting)..

90% of plugins could be one of:

**A external binary**:
* Universally usable when using json/.. output and thus also helpful to other languages (especially bash)
* Adding a `def --wrapper` is in my eyes easier than adding a plugin (both to a config and a script)
* More lightweight (if rust: `pico_args` vs all of `nu-protocol`, etc; otherwise all the boilerplate vs `import json; json.dumps(data)`)

**A nu library**:
* Why would you need a plugin for a bookmark manager? if you want to go overboard use `stor`, tho a simple `json` file would be enough..
* Easy to use in scripts, do not need as much babysitting, no compile-time, often faster, etc

### If/Once binaries registering serialized outputs is a thing plugins are redundant

See `Plugins are not powerful enough`.

Currently plugins are essentially binaries + a very limited `def --wrapped` (in a real `def --wrapped` you can edit env vars, etc).

---

## std

My first thought when `std` was introduced was "great builtin commands with worse performance".  
But it has shifted to: oh, right that buggy piece of startup-time slowdown exists... maybe someone else likes it..

hold your pitchforks, so that i can explain:

### `std/log`

The first thing from `std` i ever tried was `std/log`. and it was broken.  
I tried again some time later and it was still erroring. So i decided to write [a config snippet to fix it](https://github.com/Jan9103/nu-snippets/blob/main/misc/std-logging-fix.nu) and give it a try anyways.  
Over 2 years after the introduction i tried it again: It was still broken.

This is why i consider `std` to be buggy.  
This might be the only piece of broken `std` code, but first impressions are very strong.  
And since it is both the part I'm most interested in and has been broken for years...

### startup-time

```
> bench {|| nu -n -c '$nu.startup-time' } {|| nu --no-std-lib -n -c '$nu.startup-time' } --pretty
Benchmark 1: {|| nu -n -c '$nu.startup-time' }
        24ms 15µs 35ns +/- 6ms 604µs 523ns
Benchmark 2: {|| nu --no-std-lib -n -c '$nu.startup-time' }
        13ms 565µs 904ns +/- 1ms 119µs 617ns

{|| nu --no-std-lib -n -c '$nu.startup-time' } ran
        1.77 times faster than {|| nu -n -c '$nu.startup-time' }
```

Any more questions?

### documentation

std could be a easter-egg for all i know:
* It does not show up in `help --find` or `help commands` unless you first `use std` (but modules are buggy in `help`, so... it still does not work properly)
* It does not show up in the changelog
  * It does not show up in the breaking changes. Since i update my scripts based on the breaking changes...
* From my understanding it is less stable than builtin?
  * I can just re-implement the 1 command in my script and not have to deal with all the problems.


### `std-rfc`

nice to know that these have the half-life of hydrogen-5..  
but this just means that i personally will probably never touch them.

Why i wont use it:
* In CLI:
  * I don't know it exists (see the documentation point - but its even more hidden)
  * I don't want to bother with learning a new command if 2 existing commands do the job well enough
  * It will change again tomorrow anyway. why bother learning today's syntax?
* In Public scripts:
  * No. Just no. Cross-nu version compatibility is enough of a problem with builtin commands since some fedora users still use `0.90` (and even worse with some self-compilers or `cargo install`ers) while most are on `0.105`...
  * If it gets moved into std: everything breaks and i need a compatibility function (which might be impossible due to conditional `use` being tricky)
  * If it gets rejected: i have to re-implement it
  * If it is new in std-rfc: old nu versions do not have it
  * If the syntax changes: once again: compatibility function (probably bigger than just re-implementing it)
* In Private scripts:
  * Do i look as if i want to keep checking these after every nu update?

Additionally:
* The test cycle is horrendous. A iteration of a command takes 6 weeks..

Suggestion:
* Make it independent from nu and distribute it separately with proper versioning (how about major and minor being nu version and patch being within that nu version)
  * Versioning makes it somewhat usable in public scripts - i can just rely on a old version
    * Since old versions don't get maintained and things still get removed I'd probably still not use it tho
  * People actually test a recent version and not something 5.5 weeks old
  * Startup time does not increase as much
  * etc

---

## "Other" commands

I categorize nu commands in "commands", and "other commands" in my head.  

"commands" include: `get`, `http get`, `save --raw` / `open --raw`, `from json` / `to json`, `str contains`, `if`, `loop`, `for`, `each`, `where`, `columns`, etc

"other commands" include: `find`, `filter`, `seq`, `roll`, `rotate`, `pwd`, `overlay`, `math`, `bits`, `grid`, `detect columns` etc

Why this arbitrary sorting? Because i "trust" "commands" and avoid using "other commands".

* `find`: a invisible footgun
  * `where ($it | str contains "foo")` finds items containing "foo"
  * `find "foo"` returns data i never feed into it
* `grid`: so hyper-specific it is basically never useful
  * `do {|| cd ..; ls } | grid --color` does not work
  * `ps | grid --color` does not highlight high ram usage
  * `grid --color {|| if $in == 0 { 'green' } else { 'red' } }` does not exist
  * to get a specific column amount you need a `loop` and `try`
  * etc
* `roll`: i have yet to find a single usecase.
* `rotate`: funny? idk what this is used for. looks like a worse `transpose`.
* `pwd`: so.. why not just use `$env.PWD`?
* `seq`: yay a alias for range (and i mean `..`, not the `range` command)
* `detect columns`: probably nice for REPL, but if i need it its for a script and `parse -r` is just way more reliable
* `echo`: a new user footgun and unreliability
  * new users think this means `print` thanks to bash, etc and then open random bugs
  * it usually does nothing.. until it does.. and thats unpredicatable behaviour
  * it used to be `deprecated` and thus i don't want to use it
* `source`
  * it used to be `deprecated` and thus i don't want to use it
  * it does not feel "nu"
  * it has random bugs every once in a while
  * `mkdir foo; touch foo/mod.nu; source foo` does not work
* `use`
  * see the `use` section
* `overlay`
  * see the `use` section
  * you cant reload a overlay from within
  * you can only hide it, removing a lot of the potential upsides
  * just `crtl+d` and `nu` are usually a lot simpler when testing a module
* etc

Why do you not trust those?  

* Nu has a lot of breaking changes. the less i use the less often my scripts need fixing.
* The less often the commands i use change.. the more stable my script.
* If a broken thing is easier to spot the better. `seq 1 2` might change its behaviour without error, but try that with `1..2`
* I just never got around to properly getting used to it.

And if i can avoid using a "other command" at the cost of using multiple "command"s i will do that:
* `generate` -> `reduce -f {state: 0, result: []} {|| ... } | get result`
* `keys` -> `transpose k v | get k`
* `pwd` -> `$env.PWD`
* `find` -> `where ($it | str contains $arg1)`
* etc

---

## Why only "sometimes" as primary shell?

i used to have it as primary all the time, but:

* My server often has performance problems (when jellyfin forgets that i disabled transcoding, etc)
* `hx a<TAB><RETURN>` in bash vs `hx a<TAB><RETURN><RETURN>` in nu
  * and when i only use `hx`, `cd`, `mkdir`, `rm`, `carog run`, `git commit -am a`, `systemctl`, etc nu is thus often just slower with no upside.
* `zip` (bash) vs `^zip` (nu) (i regularly produce `cbz` files, etc - so this is actually semi-frequent enough for me to run the wrong command in nu first)
* `doas po<TAB>` -> `doas poweroff` (bash) vs `doas po` (nu)

---

## Misc

* `script`s and stdin are.. something..
* a script with `def main [--a: list]` does not work.
  * how about parsing it as `nuon`?
* windows sucks (and i don't even use it myself - i just have to add support to my public scripts..)
  * `ssh` -> `ssh.exe`
  * `foo.py` -> not possible
  * `ln -s` -> completely different syntax and command
  * forget about dependencies. `darkhttpd` does not work on windows
  * forget about performance. `aria2c`, `rg`, etc do not exist
  * sometimes `\`, sometimes `/`, etc (ssh requires `/`, windows-specific apps sometimes require `\`, etc)
  * `$env.Path`
  * etc
* `from <windows-specific-file-format>` should either be a plugin or behind a feature flag.
  * i have to compile it for every plugin since it is in the core parts of nu..
  * i never use it
  * it adds quite a bit of compile time
  * it's dependencies are essentially unmaintained and have broken release-builds in the past
  * `sqlite` is a feature flag and way deeper engrained, more commonly used (consider history), etc
* why does nu not cache its build results? i cant run a `update all` without having to wait for nu to compile even tho there was not a single character changed and it is locked...
* `mut` feels unreliable since the presence of a `each`, etc can break it
* `each` swallows output from some commands
* `each` does sometimes swallow commands (`^zip` just does nothing, etc) - no idea how to reproduce
